---
title: "**secr** simulations REP"
author: "Murray Efford"
date: "`r Sys.Date()`"
header-includes:
   - \usepackage[utf8]{inputenc}
output:
  html_document:
    theme: united
    toc: yes
    toc_depth: 4
  pdf_document:
    toc: yes
    toc_depth: 4
  word_document: default
---

# Representative sampling

Given an area of interest defined by a single polygon, can we predict the sampling variance that results from sampling designs that differ in their coverage? We assume an inhomogeneous density surface generated by a Gaussian Random Field (GRF).

We suggest the variance of $p_\cdot(\vec x | \theta)$ over the region of interest as a measure of coverage.

Representativeness *per se* follows from the design.

## Settings

We distribute about 100 binary proximity detectors within a circular region large enough that a continuous grid is not feasible ($A \gg 900\sigma^2$}.  For $\sigma = 20$m this would mean A > 900/25 or A > 36 ha (600 x 600 m). Try 1 km x 1 km or 5 km x 5 km? 

We compare

Exact number of detectors

* SRS
* GRTS   # check distribution of distances
* GA optim

Approximate

* lacework
* rectangular subgrids
* hollow subgrids

Density surface generated as for overdispersion paper Efford and Fletcher (2024).




The same conditions were used for simulation and fitting. 

| Parameter | Value(s) |
|:-----|:-----------------------|
| detectfn | 'HHN' |
| D | $12.5 (c/2)^{-2}$ |
| lambda0  | 0.1 |
| sigma    | 20 |
| noccasions | 10 |
| buffer   | $4\sigma$ |
| nx       | 64 |

## Package version, date and platform

R version 4.3.0 (2023-04-21)  
Platform: x86_64-pc-linux-gnu (64-bit)  
Running under: Red Hat Enterprise Linux 8.6 (Ootpa)  

secrdesign_2.9.1  
secr_4.6.7  

## Simulation code

### Construct layouts

```{r layouts}
library(secrdesign)

make.layouts <- function (
        ntraps   = 100, 
        detector = 'proximity', 
        region   = circ, 
        area     = 1e6,
        param    = list(
            preset   = list(),
            uniform  = list(),
            SRS      = list(),
            GRTS     = list(),
            subgrid  = list(spacing = 20, nx = 4, hollow = FALSE),
            lacework = list (spacing = 20, times = 5)
        )) {
    onetype <- function (type, param) {
        if (type == "preset") {
            param
        }
        else if (type == "uniform") {
            make.systematic(ntraps, region = region, detector = 'proximity')
        }
        else if (type == "SRS") {
            trap.builder (ntraps, region = region, method = "SRS", detector = detector)
        }
        else if (type == "GRTS") {
            trap.builder (ntraps, region = region, method = "GRTS", detector = detector)
        }
        else if (type == "subgrid") {
            subgrid <- make.grid(nx = param$nx, ny = param$nx, spacing = param$spacing, 
                                 detector = detector, hollow = FALSE)
            spacing <- sqrt(area/(ntraps/nrow(subgrid)))
            make.systematic(cluster = subgrid, region = region, spacing = spacing)
        }
        else if (type == "subgridh") {
            subgrid <- make.grid(nx = param$nx, ny = param$nx, spacing = param$spacing, 
                                 detector = detector, hollow = TRUE)
            spacing <- sqrt(area/(ntraps/nrow(subgrid)))
            make.systematic(cluster = subgrid, region = region, spacing = spacing)
        }
        else if (type == "lacework") {
            make.lacework (region, spacing = param$spacing, times = param$times, rotate = 45, detector = detector) 
        }
    }
    types <- names(param)
    layouts <- mapply(onetype, param=param, type=types, SIMPLIFY = FALSE)
    names(layouts) <- types
    layouts
}
```

```{r check layouts}
#-------------------------------------------------------------------------------
# lacework spacing simplified from laceworkdesign.rmd
K <- function (A, spacing, times = NULL) {
    if (!is.null(times)) {
        spacing <- c(spacing[1]*times, spacing[1])
    }
    A * (2 * spacing[1] - spacing[2]) / (spacing[1]^2 * spacing[2])
}
# fix times, find along-line spacing b
f <- function(x, times = 5, A = 1e6, target = 128) {
    target - K(A, x, times)
}
times <- c(5,10,15,20)
sapply(times, function(t) uniroot(f, lower = 1, upper = 2000, times = t, A = 1e6, target = 128)$root)
# [1] 53.033 38.528 31.732 27.599

sapply(times, function(t) uniroot(f, lower = 1, upper = 2000, times = t, A = 1e5, target = 100)$root)
# [1] 18.9737 13.7840 11.3529  9.8742

set.seed(12341)
nrow(lace <- make.lacework(region = polyexample1, spacing = 19, times = 5, rotate = 45))
#-------------------------------------------------------------------------------
```

```{r}
layouts <- make.layouts (
        ntraps   = 128, 
        detector = 'proximity', 
        region   = make.circle(200, radius = 564),
        param    = list(
            # preset   = make.grid(10,10),
            uniform  = list(),
            SRS      = list(),
            GRTS     = list(),
            subgrid  = list(spacing = 20, nx = 4),
            subgridh  = list(spacing = 20, nx = 6),
            lacework = list (spacing = 38.5, times = 10)
        )) 

par(mfrow=c(2,3), mar=c(1,1,1,1))
plotone <- function(tr) {
    circ <- make.circle(200, radius = 564)
    plot(circ, hide = TRUE, gridlines = FALSE)
    lines(circ)
    plot(tr, add = TRUE)
}
mapply(plotone, layouts)
sapply(layouts, nrow)
```

```{r examine layouts}
par(mfrow=c(2,3), mar=c(3,3,3,3))
space <- function (tr) {
    plot(ecdf((sapply(1:nrow(tr), function (i) min(edist(tr[-i,], tr[i,,drop=FALSE]))))), main='')
}
lapply(layouts,space)
```

### Define REP scenarios

```{r REP scenarios, eval = TRUE, message = FALSE, results = "hide"}
source('../setup.R')
fitarg <- list(detectfn = 14)
scen <- make.scenarios(D = 12.5, noccasions = 10, detectfn = 14, 
                       lambda0 = 0.1, sigma = 20, trapsindex = 1:6)
```

```{r REP scenario summary, cache = TRUE}
scenarioSummary(scen, layouts)
```

### Run REP simulations

```{r REP run, eval = FALSE, cache = TRUE}
REPsims <- run.scenarios(nrepl = 500, scen, trapset = grid, nx = 64,
                         fit = TRUE, fit.args = fitarg, seed = 12345)
saveRDS(REPsims, file = 'REPsims.RDS')
```

## Results

```{r REP results, eval = TRUE, echo = TRUE}
REPsims <- readRDS(file = 'REPsims.RDS')
estD <- estimateSummary(REPsims)
estD
```

Note: rRMSE is the root-mean-square error divided by the true density.

$\mbox{rRMSE}(\hat D) = \frac{1}{D} \sqrt {\frac{1}{N} \sum_{i=1}^N {(D - \hat D_i)^2}}$ 

$\mbox{RB}(\hat D) = \frac{1}{N} \sum_{i=1}^N {(D - \hat D_i)}/D$ 


```{r REP figure, eval = TRUE, echo = FALSE, fig.width = 8, fig.height = 4, fig.cap = "Effect of array size on relative bias (RB) and relative root-mean-square error (rRMSE) of density estimates"}

par(mfrow=c(1,2), mar=c(4,4,1,1), mgp=c(2.4,0.7,0), bty = 'o', cex = 1, pty='s')

x <- max(dist(grid)) / (2.45 * scen$sigma[1:9] *2)

plot(0,0,type='n', xlim=c(0,2.8), ylim=c(-0.2, 0.2), 
     xlab = 'Array diameter / HR diameter', 
     ylab = expression(paste('RB (', hat(italic(D)), ')') ) )
shade(0.05)
abline(h=0, lty=2)
abline(v=0, col='grey')
addRB(x, estD[1:9,], type='o', pch=16, cex=1.2)
addRB(x, estD[10:18,], type='o', pch=24, bg = 'white', xoffset = 0.02)
legend(2, 0.2, legend=c('HHN','HEX'), pch=c(16,24), pt.bg = 'white', cex = 1)

plot(0,0,type='n', xlim=c(0,2.8), ylim=c(0, 0.5), 
     xlab = 'Array diameter / HR diameter',
     ylab = expression(paste('rRMSE (', hat(italic(D)), ')') ) )
points(x, estD[1:9,'rRMSE'], type='o', pch=16, cex = 1.2)
points(x+0.02, estD[10:18,'rRMSE'], type='o', pch=24, bg='white', cex=1.1)
legend(2, 0.5, legend=c('HHN','HEX'), pch=c(16,24), pt.bg = 'white', cex = 1)
```

## Compare Efford 2011 Table 3

Efford (2011 Ecology 92: 2202--2207) simulated area-search data with a half-normal detection function. The searched area varied from $1 \sigma^2$ to $64 \sigma^2$. We plot the results as a function of area-diameter divided by 95\% BVN home range as with the preceding simulations. Bias results when the linear diagonal of the searched area is less than about 75\% of the 95\% home-range diameter. Given the arbitrariness of both measures (area dimension, home range size) we suggest the simple rule: the grid or searched area should be at least the size of the home range.

```{r plotefford2011}
searcharea <- c(1,2,4,8,16,32,64)
diag <- sqrt(2) * sqrt(searcharea)
HR95 <- 2 * 2.45 * 1
diag/HR95
RB <- c(0.47,0.20,0.12,0.02, 0.02, 0.02,-0.01)

par(mfrow=c(1,1), mar=c(4,4,1,1), mgp=c(2.4,0.7,0), bty = 'o', cex = 1.2, pty='s')

plot(0,0,type='n', xlim=c(0,2.8), ylim=c(-0.2, 0.5), 
     xlab = 'Array diameter / HR diameter', 
     ylab = expression(paste('RB (', hat(italic(D)), ')') ) )
shade(0.05)
abline(h=0, lty=2)
addRB(x, estD[1:9,], type='o', pch=16, cex=1)
points(diag/HR95, RB, pch=21, bg='yellow')
```

