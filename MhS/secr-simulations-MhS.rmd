---
title: "**secr** simulations MhS"
author: "Murray Efford"
date: "`r Sys.Date()`"
header-includes:
   - \usepackage[utf8]{inputenc}
output:
  html_document:
    theme: united
    toc: yes
    toc_depth: 4
  pdf_document:
    toc: yes
    toc_depth: 4
  word_document: default
---

# Effect of individual heterogeneity in detection parameter $\lambda_0$ on spatial trend estimates MhS

The simulations described here are part of a series documenting the effect of 
breaching assumptions of spatially explicit capture--recapture models.

Variation among individuals in the probability of detection is a known cause of bias in many domains of capture--recapture. However, trend estimates are fairly robust (see Hines and Nichols 2002 for non-spatial scenarios, but "These approximations indicate that trap response is an especially important assumption violation that can produce substantial bias".)

## Problem description

The SECR null model assumes $\lambda_0$ and $\sigma$ are the same across individuals. We generate populations with a multi-session trend in density sampled with heterogeneous $\lambda_0$, and examine estimates of density trend with respect to a covariate, the intensity surface used to generate the data.

## Settings

Square grid of 100 binary proximity detectors at spacing $c = 2\sigma$.  

The same conditions used for simulation and fitting.

| Parameter | Value(s) |
|:-----|:-----------------------|
| detectfn | 'HHN' |
| D | approx $1 \sigma^{-2}$ |
| mean lambda0  | 0.2 |
| mean sigma    | c/2 |
| noccasions | 5 |
| buffer   | $4\sigma$ |
| nx       | 64 |

## Package version, date and platform

```{r startup, warning = FALSE, message = FALSE, results = "hold"}
source('../setup.R')
runsim  <- FALSE
results <- TRUE
figures <- TRUE
cache   <- FALSE
nrepl   <- 2000
metadata(runsim) # if FALSE picks up saved metadata.RDS
```

Note: 'grdevice' is set in setup.R to 'ragg_png' allowing graphics on NeSI.

Spatial units changed 2025-08-14: sigma = 1 m, D = 5000/ha

Density model changed 2025-09-08 to log D = beta0 + beta1 * grf, where grf is 
Gaussian random field generated by function fields::circulantEmbedding and scaled 0--1.

## Simulation code

### Define MhS scenarios

This function draws unique levels of the detection parameter lambda0 from a log-normal distribution for each member of a simulated population when used as the 'covariates' argument of `sim.popn`. 
```{r popnCV}
popn.covariates <- function (animals, ...) {
    arg <- list(...)
    CVl <- if (is.null(arg$CVlambda0)) 0 else arg$CVlambda0
    mnl <- arg$lambda0
    mns <- arg$sigma
    n <- nrow(animals)
    data.frame(lambda0 = secr::rlnormCV(n, mnl, CVl), sigma = rep(mns,n)) 
}
```

The population arguments passed to run.scenarios include the mean and CV of each detection parameter.

```{r MhS scenarios, eval = TRUE, message = FALSE, results = "hide"}
oneD <- function (mask, parm = list(beta0 = 8, beta1 = 1, aRange = 5), savegrf = TRUE) {
    grid <- list(x = unique(mask$x), y = unique(mask$y)) 
    obj  <- fields::circulantEmbeddingSetup(
        grid, Covariance = "Exponential", aRange = parm$aRange)
    grf  <- fields::circulantEmbedding( obj)
    grf  <- pnorm(as.numeric(grf))  # transform to (0,1)
    out  <- exp(parm$beta0 + parm$beta1*grf)
    if (savegrf) attr(out, 'grf') <- grf
    out
}
poparg <- expand.arg(
        model2D    = 'IHP',
        Ndist      = 'poisson',
        covariates = "popn.covariates", 
        keep.mask  = TRUE,
        lambda0    = 0.2, 
        sigma      = 1, 
        CVlambda0  = seq(0,0.8,0.2)
)
beta0 <- log(2000)
beta1 <- log(10)
for (i in 1:5) {
    poparg[[i]]$D <- oneD
    poparg[[i]]$details <- list(beta0 = beta0, beta1 = beta1, aRange = 5)
}

scen <- make.scenarios(
    D          = 10000,   # approx!
    noccasions = 5, 
    detectfn   = 14, 
    lambda0    = 0.2, 
    sigma      = 1,        # m
    popindex   = 1:length(poparg), 
    fitindex   = 1)
```

```{r Mh scenario summary, cache = cache}
grid <- make.grid(nx = 10, ny = 10, spacing = 2, detector = "proximity")
scenarioSummary(scen, grid)
```

### Example

```{r exampleplot, eval = TRUE, warning = FALSE, fig.cap = 'Fig. 1. Realisation of LGCP intensity surface and simulated AC locations.'}
set.seed(1234)
msk <- make.mask(grid, buffer=4)
D <- oneD(msk, parm = list(beta0 = beta0, beta1 = beta1, aRange = 5), savegrf = TRUE)
covariates(msk)$grf <-  attr(D, 'grf')
covariates(msk)$D <-  D
pop <- sim.popn(D = D, core = msk, buffer = 0, model2D = "IHP")
ch <- sim.capthist(grid, popn = pop, detectpar = list(lambda0 = 0.1, sigma = 1), 
                   noccasions = 5, detectfn = 14, savepopn = TRUE)
par(mar = c(3,1,1,2))
plot(msk, cov = 'grf', dots = F, border = 1)
plot(pop, cex = 0.5, pch = 16, frame = FALSE, add = TRUE)
plot(grid, add = TRUE)
```

### Run MhS simulations

Package 'fields' offers function circulantEmbedding() to generate a Gaussian random field.

```{r MhS-run, eval = runsim, cache = cache, warning = FALSE, message = FALSE}
# clunky way to add grf as mask covariate
# run.scenarios adds covariates of mask saved from sim.popn() to fitarg$mask (secrdesign>2025-08-16)
CHfn <- function(traps, popn, detectfn, detectpar, noccasions) {
    ch <- sim.capthist(traps, popn, detectfn, detectpar = list(individual = TRUE), 
                       noccasions, savepopn = TRUE)
    tmp <- attr(attr(ch,'popn'),'mask')
    covariates(tmp)$grf <- attr(covariates(tmp)$D, 'grf')
    attr(attr(ch,'popn'),'mask') <- tmp
    ch
}
fitarg   <- list(
  list (
    list(detectfn = 'HHN', CL = TRUE,  model = list(lambda0 ~ 1, D~grf)),
    list(detectfn = 'HHN', CL = FALSE, model = list(lambda0 ~ 1, D~grf)),
    list(detectfn = 'HHN', CL = FALSE, model = list(lambda0 ~ 1, D~grf), details = list(distribution = "binomial"))
  )
)

mycoef <- function(object, ...) {
  emptycoef <- function (rownames) {
    nr <- length(rownames)
    rNA <- rep(NA, nr)
    data.frame(beta = rNA, SE.beta = rNA, lcl = rNA, ucl = rNA, row.names = rownames)
  }
  if (inherits(object, 'secr')) {
    if (object$CL) {
      Dhat <- mean(covariates(derivedDsurface(object))$D.0)
      cvn <- CV(apply(object$capthist,1,sum))
      time <- object$proctime
      out <- rbind(derivedDcoef(object), cvn = cvn,  Dhat = Dhat, time = time)
      out[5:7, 2:4] <- NA
    }
    else {
      Dhat <- mean(covariates(predictDsurface(object))$D.0)
      cvn <- CV(apply(object$capthist,1,sum))
      time <- object$proctime
      out <- rbind(coef(object), cvn = cvn,  Dhat = Dhat, time = time)
      out[5:7, 2:4] <- NA
    }
      out
  }
  else emptycoef(c('D', 'D.grf', 'lambda0', 'sigma', 'cvn','Dhat','time'))
}
exfn <- function (fits, vcv = FALSE, ...) {
  # fits is secrlist
  lapply(fits, function(fit) mycoef(fit))
}

msk <- make.mask(grid, nx = 64, buffer = 4)
MhSsims <- run.scenarios(
    nrepl     = nrepl, 
    scenarios = scen, 
    trapset   = grid, 
    maskset   = msk,
    fit       = "multifit", 
    pop.args  = poparg, 
    CH.function = "CHfn",
    fit.args  = fitarg, 
    seed      = 123, 
    extractfn = exfn)

saveRDS(MhSsims, file = 'MhSsims.RDS')
```

```{r MhS readRDS, echo = FALSE}
MhSsims <- readRDS(file = 'MhSsims.RDS')
```

MhSsims completed with `r nrepl` replicates on `r nc` threads in `r round(MhSsims$proctime/60,1)` minutes.

## Results

```{r MhS table, eval = results, echo = TRUE, results = "hold"}
options(width = 110, digits = 4)
MhSsims <- readRDS(file = 'MhSsims.RDS')
mn <- function(x) mean(x, na.rm=TRUE)
se <- function(x) sd(x, na.rm=TRUE)/sqrt(sum(!is.na(x)))
nv <- function(x) sum(!is.na(x))

onefit <- function(fit = 1) {
    onesim <- function (sim, parm, fn) {
        fn(sapply(sim, function(x) x[[fit]][parm,'beta']))
    }
    df <- data.frame(
        CVlambda0 = seq(0,0.8,0.2),
        nvalid    = sapply(MhSsims$output, onesim, 'D',        fn = nv),
        D         = sapply(MhSsims$output, onesim, 'D',        fn = mn)-beta0,
        seD       = sapply(MhSsims$output, onesim, 'D',        fn = se),
        Dgrf      = sapply(MhSsims$output, onesim, 'D.grf',    fn = mn)-beta1,
        seDgrf    = sapply(MhSsims$output, onesim, 'D.grf',    fn = se),
        cvn       = sapply(MhSsims$output, onesim, 'cvn',      fn = mn),
        Dhat      = sapply(MhSsims$output, onesim, 'Dhat',     fn = mn),
        time      = sapply(MhSsims$output, onesim, 'time',     fn = mn),
        setime    = sapply(MhSsims$output, onesim, 'time',     fn = se)
    )
    df
}
lapply(1:3, onefit)
```

```{r MhS figure, eval = figures, echo = TRUE, fig.width = 8, fig.height = 4, fig.cap = "Fig. 2. Relative bias of beta estimates given individual variation" }
cvltext <- expression(paste("CV( ", lambda[0], " )"))
x <- seq(0,0.8,0.20)
par(mfrow = c(1,1), mar = c(4,4,1,1), mgp = c(2.4,0.7,0), bty = 'o', pty = 's', las = 0)
offset <- 0.005
plot(0,0, type = 'n', xlim = c(0,0.8), ylim = c(-0.3,0.2), 
     xlab = cvltext, ylab = '', las=1)
mtext(side=2, 'Estimated bias', line = 2.5, las=0)
abline(h = 0, lty = 2)
addRB(x-offset, onefit(1), mean = 'D', se = 'seD', type = 'o', pch = 21, bg = 'white')
addRB(x+offset, onefit(1), mean = 'Dgrf', se = 'seDgrf', type = 'o', pch = 16)

legend ('topright', legend = c(expression(italic(hat(beta[1]))), 
                               expression(italic(hat(beta[0])))), 
        pch=c(16,21), pt.bg = 'white', lty = 1)
```

```{r timing}
par(mar=c(4,4,4,4), pty='s')
plot(0,0,type='n',xlim=c(-0.05,0.85), ylim=c(0,4), 
     xlab = cvltext, ylab = 'Execution time   s' ) 
offset <- c(-0.01,0,0.01)
cols <- c('yellow', 'orange','forestgreen') 
for (f in 1:3) {
    df <- onefit(f)
    x <- df$CVlambda0 + offset[f]
    segments (x, df$time + 2* df$setime, x, df$time - 2* df$setime)
    points (x, df$time, type = 'o', pch = 20+f, bg = cols[f],cex = 1.2)
}
legend(0.45,3.9, legend=c('Full, binomial', 'Full, Poisson', 'Conditional'), 
       pch = (21:23)[3:1], pt.cex = 1.2, pt.bg = cols[3:1] )
```


```{r timing2}
# proportion of time saved
1-onefit(1)$time /  onefit(2)$time
```

```{r comparefit}
comparefit <- function(fit1 = 1, fit2 = 2) {
  onesim <- function (sim, parm, fn, ratio = FALSE) {
    if (ratio) {
      obs <-sapply(sim, function(x) x[[fit2]][parm,'beta']) /
        sapply(sim, function(x) x[[fit1]][parm,'beta'])
    } else {
      obs <- sapply(sim, function(x) x[[fit1]][parm,'beta']) -
        sapply(sim, function(x) x[[fit2]][parm,'beta'])
    }
    fn(obs)
  }
  df <- data.frame(
    CVlambda0   = seq(0,0.8,0.2),
    nvalid      = sapply(MhSsims$output, onesim, 'D',        fn = nv),
    deltaD      = sapply(MhSsims$output, onesim, 'D',        fn = mn),
    sedeltaD    = sapply(MhSsims$output, onesim, 'D',        fn = se),
    deltaDgrf   = sapply(MhSsims$output, onesim, 'D.grf',    fn = mn),
    sedeltaDgrf = sapply(MhSsims$output, onesim, 'D.grf',    fn = se),
    deltatime   = sapply(MhSsims$output, onesim, 'time',     fn = mn),
    sedeltatime = sapply(MhSsims$output, onesim, 'time',     fn = se),
    ratiotime   = sapply(MhSsims$output, onesim, 'time',     fn = mn, ratio = TRUE),
    seratiotime = sapply(MhSsims$output, onesim, 'time',     fn = se, ratio = TRUE)
  )
  df
}
comparefit(1,2)
comparefit(1,3)
```

## Interpretation

Estimates of coefficient for density-covariate relationship are insensitive to individual variation in $\lambda_0$.

## References

Hines, J. E. and Nichols, J. D. 2002. Investigations of potential bias in the estimation of $\lambda$ using Pradel's (1996) model for capture--recapture data. Journal of Applied Statistics 29: 573--587.

Nichols, J. D. and Hines, J. E. 2002. Approaches for the direct estimation of $\lambda$, and demographic contributions to $\lambda$, using capture--recapture data, Journal of Applied Statistics 29: 539--568.