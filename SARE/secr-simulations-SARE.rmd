---
title: "**secr** simulations SARE"
author: "Murray Efford"
date: "`r Sys.Date()`"
header-includes:
   - \usepackage[utf8]{inputenc}
output:
  html_document:
    theme: united
    toc: yes
    toc_depth: 4
  pdf_document:
    toc: yes
    toc_depth: 4
  word_document: default
---

# Spatially autocorrelated random effects SARE

The simulations described here are part of a series documenting the effect of 
breaching assumptions of spatially explicit capture--recapture models.

Unmodelled spatial variation in the probability of detection is a potential cause of bias in density estimates from null-model SECR. There are subtleties here: we may be talking about either

1. The probability of detecting an animal at any detector, given its AC, or
2. The probability that a detector will detect an animal given its presence in the vicinity

The second involves a property of the detector that may vary independently of other detectors or in a spatially autocorrelated fashion (hence 'spatially autocorrelated random effects' or SARE
following Dey et al. (2023)). Several papers have simulated detector variation as resulting from a Gaussian random field. The field is defined across continuous space, but evaluated only at the detector locations, for which the variation is multivariate normal (MVN). Spatial autocorelation is determined by the covariance function (usually exponential) and its spatial scale. Distances between detectors are multiplied by the covariance spatial scale parameter for which we use the symbol $\phi$.

The cases identified by Dey et al. (2023:3) are: 

| Case | Label | Interpretation |
|:---------|:---------------------|:-----------------|
| $\phi = 0$ | SCR | no heterogeneity, detectors identical |
| $0 < \phi < \infty$ | SARE| spatially autocorrelated random effect|
| $\phi \to \infty$ | RE| independent random effect each detector RE |

A cumulative effect of detector-level variation (2) is to drive differences in detection probability among animals (1). This is because an AC is likely to be exposed to a unique set of nearby detectors. Detector variation may bias density estimates from a null model purely because of this individual heterogeneity, although we will see that this is hard to pin down.

Here we reproduce selected SARE simulations from the papers of Royle et al. (2013), Moqanaki et al. (2021) and Dey et al. (2023). Two complications will be covered in later documents:

1. The SARE model is unrealistic as a model of animal activity as it posits potentially large variation among individuals in total activity. It is biologically more realistic to normalise activity using an integral of the underlying Gaussian random field (Efford 2014).
2. The SARE model assumes each animal responds similarly to variation among detectors. Stevenson et al. (2021) treated the probability of detecting animal $i$ at detector $k$ as a function of a Gaussian latent detection field unique to each animal, and Hooten et al. (2024) independently described a Bayesian implementation.

| Study | Code | Covariance | detectfn^2^ | Detection |
|:-------|:---|:--------------------|:--|:-----------|
| Royle et al. 2013 | RSF | $X \sim \mbox{MVN}(0, \Sigma), \Sigma_{jj'} = \exp(-\phi d_{jj'}), \phi = 1/\mbox{scale}$ | HHN | $\lambda_{0_j} = \exp(\alpha_0 + \alpha_2 X_j)$|
| Moqanaki et al. 2021^1^ | MOQ | $X \sim \mbox{MVN}(0, \Sigma), \Sigma_{jj'} \approx \exp(-\phi^2 d_{jj'}^2)$| HN | $g_{0_j} = \mbox{logit}^{-1}(\beta_0 + \beta_X f(X_j))$|
| Dey et al. 2023 | DEY | $X \sim \mbox{MVN}(0, \Sigma), \Sigma_{jj'} = \exp(-\phi d_{jj'})$| HN | $g_{0_j} = \mbox{logit}^{-1}(\beta_0 + X_j)$ |

1. The code used by Moqanaki et al. (2021) included an ad hoc change to the multivariate-normal simulator (replacing chol(V) by V) that effectively changed the covariance function from exponential to squared-exponential. Also, values of the spatial covariate $X$ were scaled to be uniformly distributed between -1.96 and 1.96 (indicated here as $f(X)$).
2. **secr** detection function HN = halfnormal, HHN = hazard halfnormal (cloglog link of Royle et al. 2013).

Various scenarios may lead to SARE. 

* deviation of home ranges from strict circularity, perhaps because the resources used by an individual are distributed unevenly in space (Royle et al. 2013)
* unrecorded variation in sampling effort (Dey et al. 2023)
* unrecorded variation in the effectiveness of detectors, perhaps due to resource-driven changes in behaviour near detectors

```{r moranX}
# extractfn for raw capthist 
# autocorrelation of X covariate at detectors, 
# assumed to be saved as attribute 'X' of ch.
# Weight window considers adjacent detectors (queen's move).
MoranX <- function (ch, varname = 'X', ...) {
    if (is.null(attr(ch, varname))) stop (var, " attribute not found")
    X <- attr(ch, varname)
    Xraster <- raster(as.mask(traps(ch)), values = X)
    out <- c(
        n          = nrow(ch),
        detections = sum(ch),
        dnpa       = sum(ch)/nrow(ch), 
        rpsv       = RPSV(ch, CC = TRUE),
        mean.X     = mean(X),
        median.X   = median(X),
        sd.X       = sd(X),
        MoranI     = raster::Moran(Xraster, ...)
    )
    names(out)[5:7] <- paste0(c('mean.', 'median.', 'sd.'), varname)
    out
}

MoranXSummary <- function(sims, var = 'rpsv') {
    output <- summary(sims)$OUTPUT
    var <- match(var, rownames(output[[1]]))
    sumX <- sapply(output, '[', var, c('mean','se'))
    apply(sumX,1,unlist)
}

```

# Royle et al. 2013 RSF

## Alternative capthist simulator
```{r RSFfn, echo = TRUE, eval = TRUE}
simRSF.capthist <- function (traps, popn, detectfn, detectpar, noccasions = 10, 
                             alpha2 = 1, scale = 1, ...)
{
    if (!(detectfn == 14 || detectfn == "HHN")) stop ("detectfn not implemented")
    K <- nrow(traps)
    cov <- exp(-edist(traps,traps)/scale)     
    X <- mvtnorm::rmvnorm(1, mean = rep(0, K), sigma = cov) 
    alpha0 <- log(detectpar$lambda0)
    lambda0 <- exp(alpha0 + alpha2 * X)       # length K vector
    # lambda0 input to sim.capthist is matrix noccasions x ndetectors
    detectpar$lambda0 <- matrix(lambda0, byrow = TRUE, nrow = noccasions, ncol = K)
    covariates(traps) <- data.frame(X = as.numeric(X))
    ch <- sim.capthist(traps, popn, detectfn, detectpar, noccasions)
    attr(ch, 'X') <- X
    attr(ch, 'lambda0') <- lambda0
    ch
}
```

```{r RSF scenarios, message = FALSE}
source('../setup.R')
grid49 <- make.grid(7,7, spacing = 5, detector = 'proximity')
mask49 <- make.mask(grid49, buffer = 8)
poparg <- list(Ndist = 'fixed')
detarg <- expand.arg(alpha2        = 1.0,  # coefficient of random effect
                     scale         = 5)    # scale of covariance
fitarg <- list(list(model    = lambda0~1, 
                    detectfn = 'HHN', 
                    details  = list(distribution = 'binomial')),
               list(model    = lambda0~X, 
                    detectfn = 'HHN', 
                    details  = list(distribution = 'binomial')))
scen <- make.scenarios(noccasions = 10, 
                       D          = c(100,200)/maskarea(mask49),     
                       lambda0    = exp(-2),   # exp(alpha0) 
                       sigma      = 2, 
                       detectfn   = 'HHN', 
                       detindex   = 1:length(detarg),
                       fitindex   = 1:2)
```

```{r RSF run, eval = FALSE}
RSFsims <- run.scenarios(
    nrepl       = 100, 
    scenarios   = scen, 
    trapset     = grid49, 
    maskset     = mask49, 
    CH.function = "simRSF.capthist", 
    fit         = TRUE, 
    pop.args    = poparg, 
    det.args    = detarg, 
    fit.args    = fitarg)
saveRDS(RSFsims, file = 'RSFsims.RDS')
```

## Results

First confirm simulated counts of individuals $n$ and recaptures $r$ are reasonable:
```{r RSF counts}
RSFsims <- readRDS(file = 'RSFsims.RDS')
getcounts(RSFsims)  # requires secrdesign 2.9.1
```

And confirm bias in $\hat D$ from null model (scenarios 1,2) disappears when the trap covariate is included in the model (scenarios 3,4):
```{r RFS summary}
estimateSummary(RSFsims)
```

## Extend to a range of values for $\alpha_2$

We simulate only the lower density ($N = 100$) and fit only the null model. Values of $\alpha_0$, scale and poparg are as before.

```{r RSF scenarios2, eval = FALSE}
detarg <- expand.arg(alpha2        = seq(0,1.4,0.2), 
                     scale         = 5)
scen <- make.scenarios(noccasions = 10, 
                       D          = 100/maskarea(mask49),     
                       lambda0    = exp(-2), 
                       sigma      = 2, 
                       detectfn   = 'HHN', 
                       detindex   = 1:length(detarg),
                       fitindex   = 1)  # null model only
RSFsims2 <- run.scenarios(
    nrepl       = 100, 
    scenarios   = scen, 
    trapset     = grid49, 
    maskset     = mask49, 
    CH.function = "simRSF.capthist", 
    fit         = TRUE, 
    pop.args    = poparg, 
    det.args    = detarg, 
    fit.args    = fitarg)
saveRDS(RSFsims2, file = 'RSFsims2.RDS')
```

```{r RSF scenarios2X, echo = FALSE, eval = FALSE, cache = TRUE}
RSFsims2X <- run.scenarios(
    nrepl       = 200, 
    scenarios   = scen, 
    trapset     = grid49, 
    maskset     = mask49, 
    CH.function = "simRSF.capthist", 
    fit         = FALSE, 
    pop.args    = poparg, 
    det.args    = detarg, 
    extractfn   = MoranX)
tmp <- MoranXSummary(RSFsims2X)
tmpdnpa <- MoranXSummary(RSFsims2X, 'dnpa')
par(mar=c(4,4,4,4))
plot(0,0,type='n',xlim=c(0,1.4), ylim=c(0,4), xlab='alpha2',ylab='RPSV')
addRB(seq(0,1.4,0.2), tmp, 'mean','se')
addRB(seq(0,1.4,0.2), tmpdnpa, 'mean','se', pch = 16)
mtext(side=4, 'Detections per animal', adj=0.7)
```

## Results of extended simulation

```{r RSF 2 results, eval = TRUE, cache = TRUE}
RSFsims2 <- readRDS(file = 'RSFsims2.RDS')
estD <- estimateSummary(RSFsims2, 'D')
estL <- estimateSummary(RSFsims2, 'lambda0')
estS <- estimateSummary(RSFsims2, 'sigma')
cbind(alpha2 = seq(0,1.4,0.2), getcounts(RSFsims2)[,-5])
```
The number of recaptures increases radically with $\alpha_2$, but from the more gradual increase in dpa (detectors per animal) we infer this is due to repeat detections at favoured detectors. 

```{r RSF 2 figure, eval = TRUE, cache = TRUE}
leg <- c('D', 'lambda0','sigma')
alpha2 <- seq(0,1.4,0.2)
par(mfrow=c(1,1), mar=c(5,4,2,2), mgp=c(2.4,0.7,0), pty='s', bty = 'o')
plot(1,1, type = 'n', xlim=c(0,1.4), ylim=c(-0.4,0.6), xlab = 'alpha2', ylab = 'RB')
abline(h=0, lty=2)
addRB(alpha2, estL, pch=21, bg='white', star = 0.6)
addRB(alpha2, estS, pch=24, bg='white', star = 0.6)
addRB(alpha2, estD, pch=16)
legend(0.02, -0.2, legend = leg, pch=c(16,21,24), cex=0.85)
```

## Effect of normalisation


```{r RSFfn normalized, echo = FALSE, eval = TRUE}
simRSFn.capthist <- function (traps, popn, detectfn, detectpar, noccasions = 10, 
                             alpha2 = 1, scale = 1, normalize = TRUE, ...)
{
    if (!(detectfn == 14 || detectfn == "HHN")) stop ("detectfn not implemented")
    K <- nrow(traps)
    N <- nrow(popn)
    msk <- make.mask(traps, buffer = 8 * detectpar$sigma)
    M <- nrow(msk)
    alpha0 <- log(detectpar$lambda0)
    alpha1 <- -1 / (2*detectpar$sigma^2)
    
    # generate instance of random field
    if (!(requireNamespace("RandomFields"))) stop("install RandomFields")
    model <- RandomFields::RMexp(var = 1, scale = scale) + RandomFields::RMtrend(mean = 0)
    covariates(msk)$X <- RandomFields::RFsimulate(model, x = as.matrix(msk))@data[,1]
    traps <- addCovariates(traps, msk)
    
    # field value at detectors...
    Zmat <- matrix(covariates(traps)$X, nrow = N, ncol = K, byrow = TRUE)
    
    if (normalize) {
        # adjust as per Efford 2014:600
        alpha0 <- alpha0 + log(2*pi*detectpar$sigma^2)
        
        # field value at each mask point...
        Xmat <- matrix(covariates(msk)$X, nrow = N, ncol = M, byrow = TRUE)
        
        # sum space use for each individual in population
        dm <- secr::edist(popn, msk)             # N x M matrix
        loglams <- alpha1 * dm^2  + alpha2 * Xmat
        C <- apply(exp(loglams), 1, sum)   # N vector
    }
    else {
        C <- 1
    }
    
    # N x K matrix of detection probabilities
    d <- secr::edist(popn, traps)
    loglam <- alpha1 * d^2 + alpha2 * Zmat
    p <- 1 - exp(- exp(alpha0 + loglam - log(C)))
    
    if (noccasions>1) {
        # replicate occasions
        p <- aperm(apply(p,1:2,rep,noccasions), c(2,1,3))
    }
    if (detector(traps)[1] == 'proximity') {
        ch <- rbinom(N*K*noccasions, 1, p)
    }
    else if (detector(traps)[1] == 'count') {
        ch <- rpois(N*K*noccasions, exp(alpha0 + loglam - log(C)))
    }
    else stop ("detector not proximity or count")
    ch <- array(ch, dim=c(N,noccasions,K))
    rownames(ch) <- 1:N
    ch <- ch[apply(ch, 1, function(x) sum(x) > 0),,, drop = FALSE]
    class(ch) <- 'capthist'
    traps(ch) <- traps
    ch
}
```

```{r test, echo = FALSE, eval = FALSE}
source('../setup.R')
grid49 <- make.grid(7,7, spacing = 5, detector = 'proximity')
mask49 <- make.mask(grid49, buffer = 8)
bigmask49 <- make.mask(grid49, buffer = 16)
pop <- sim.popn(200/maskarea(mask49), grid49, Ndist = 'fixed', buffer = 8)
ch <- simRSFn.capthist (grid49, pop, 'HHN', 
                        list(lambda0 = exp(-2), sigma=2), noccasions = 10, 
                             alpha2 = 1, scale = 5, normalize = TRUE)
summary(ch)
plot(ch, tracks = T, border = 2, rad = 0.5)
RPSV(ch, CC=TRUE)
```

```{r RSF scenarios3, eval = FALSE}
poparg <- list(Ndist = 'fixed')
detarg <- expand.arg(alpha2        = seq(0,1.4,0.2), 
                     scale         = 5,
                     normalize     = c(TRUE, FALSE))
fitarg <- list(model    = lambda0~1, 
               detectfn = 'HHN', 
               details  = list(distribution = 'binomial'))
scen <- make.scenarios(noccasions = 10, 
                       D          = 200/maskarea(mask49),     
                       lambda0    = exp(-2), 
                       sigma      = 2, 
                       detectfn   = 'HHN', 
                       detindex   = 1:length(detarg),
                       fitindex   = 1)  # null model only
RSFsims3 <- run.scenarios(
    nrepl       = 500, 
    scenarios   = scen, 
    trapset     = grid49, 
    maskset     = mask49, 
    CH.function = "simRSFn.capthist", 
    fit         = TRUE, 
    pop.args    = poparg, 
    det.args    = detarg, 
    fit.args    = fitarg)
saveRDS(RSFsims3, file = 'RSFsims3.RDS')
```

## Results of extended simulation with normalisation

```{r RSF 3 results, eval = TRUE, cache = TRUE}
RSFsims3 <- readRDS(file = 'RSFsims3.RDS')
estD <- estimateSummary(RSFsims3, 'D')
estL <- estimateSummary(RSFsims3, 'lambda0')
estS <- estimateSummary(RSFsims3, 'sigma')
cbind(alpha2 = seq(0,1.4,0.2), getcounts(RSFsims3)[,-5])
```
The number of recaptures increases radically with $\alpha_2$, but there is a much more gradual increase in dpa (detectors per animal) so we infer the increase in recaptures is due to repeat detections at favoured detectors. 

```{r RSF 3 figure, eval = TRUE, cache = TRUE}
leg <- c('D', 'lambda0','sigma')
alpha2 <- seq(0,1.4,0.2)
par(mfrow=c(1,2), mar=c(5,4,2,2), mgp=c(2.4,0.7,0), pty='s', bty = 'o')
for (rw in 2:1) {
    r <- (rw-1)*8+(1:8)
    plot(1,1, type = 'n', xlim=c(0,1.4), ylim=c(-0.4,0.4), xlab = 'alpha2', ylab = 'RB')
    abline(h=0, lty=2)
    addRB(alpha2, estL[r,], pch=21, bg='white', star = 0.4)
    addRB(alpha2, estS[r,], pch=24, bg='white', star = 0.4)
    addRB(alpha2, estD[r,], pch=16)
    legend(0.02, -0.2, legend = leg, pch=c(16,21,24), cex=0.85)
    mtext(side=3, c('normalized','unnormalized')[rw])
}
```

```{r RSF scenarios 4, eval = FALSE}
source('../setup.R')
grid49 <- make.grid(7,7, spacing = 5, detector = 'proximity')
mask49 <- make.mask(grid49, buffer = 8)
detarg <- expand.arg(alpha2        = seq(0,1.4,0.2), 
                     scale         = c(1e-4,1e4))   # 1/phi
fitarg <- list(model    = lambda0~1, 
               detectfn = 'HHN', 
               details  = list(distribution = 'binomial'))
scen <- make.scenarios(noccasions = 10, 
                       D          = 200/maskarea(mask49),     
                       lambda0    = exp(-2), 
                       sigma      = 2, 
                       detectfn   = 'HHN', 
                       detindex   = 1:length(detarg),
                       fitindex   = 1)  # null model only
RSFsims4 <- run.scenarios(
    nrepl       = 500, 
    scenarios   = scen, 
    trapset     = grid49, 
    maskset     = mask49, 
    CH.function = "simRSF.capthist", 
    fit         = TRUE, 
    pop.args    = poparg, 
    det.args    = detarg, 
    fit.args    = fitarg)
saveRDS(RSFsims4, file = 'RSFsims4.RDS')
```

```{r RSF 4 figure, eval = TRUE, cache = TRUE, fig.cap = "Relative bias of null-model density estimates under three scenarios for variation among detectors. 'phi' is the coefficient of the exponential covariance function (phi = 1/scale). Detectors are homogeneous (share the same value) when phi = 0, and independent as phi tends to infinity"}
RSFsims3 <- readRDS(file = 'RSFsims3.RDS')
RSFsims4 <- readRDS(file = 'RSFsims4.RDS')
for (i in 1:16) for (j in 100:1) if (nrow(RSFsims4$output[[i]][[j]])==0) RSFsims4$output[[i]][[j]] <- NULL
estD3 <- estimateSummary(RSFsims3, 'D')
estD4 <- estimateSummary(RSFsims4, 'D', valid=c(0,5000))
leg <- c('homogeneous', 'SARE','independent RE')
alpha2 <- seq(0,1.4,0.2)
par(mfrow=c(1,1), mar=c(5,4,2,2), mgp=c(2.4,0.7,0), pty='s', bty = 'o')
plot(1,1, type = 'n', xlim=c(0,1.4), ylim=c(-0.4,0.4), xlab = 'alpha2', ylab = 'RB')
abline(h=0, lty=2)
addRB(alpha2, estD4[9:16,], pch=17)
addRB(alpha2, estD3[9:16,], pch=16)
addRB(alpha2, estD4[1:8,], pch=18)
legend(0.02, -0.2, legend = leg, pch=c(17,16,18), cex=0.85)
```

# Moqanaki et al (2021) 

Moqanaki et al (2021) investigated the effect of spatial autocorrelation in the detector-specific baseline probability of detection $g_{0_j}$ (notation has been altered for consistency with **secr**). They simulated both continuous variation in detector properties and scenarios in which detectors with low and high probability were clustered to varying degrees (low, intermediate and high). We focus on the continuous case. Their simulations generate a spatially correlated covariate $X_j$ for each detector $j$. The marginal distribution of $X_j$ is uniform with support in the range -1.96 to 1.96. Then 
$$g_{0_j} = \mbox{logit}^{-1} (\beta_0 + \beta_X X_j)$$.
In their simulations $\mbox{logit}^{-1} (\beta_0) = 0.15$ and $\beta_j$ took values $-0.5$ or $-2.0$. The sign of $\beta_X$ is not material for $X_j$ distributed symmetrically about zero, so long as the autocorrelation of positive and negative $X_j$ is the same.

## Problem description

We wish to reproduce the simulation results of Moqanaki et al. (2021) for a range of values of  $\beta_X$ and $\phi$.

## Settings

Square grid of 400 binary proximity detectors at unit spacing $c$.  

The same conditions used for simulation and fitting.

| Parameter | Value(s) |
|:-----|:-----------------------|
| detectfn | 'HN' |
| D | $0.71747 \sigma^{-2}$ |
| N | fixed |
| k | 0.84704 |
| base g0  | 0.15 |
| sigma    | $1.5c$ |
| noccasions | 1 |
| buffer   | $3\sigma$ |
| nx       | 64 |

## Package version, date and platform

R version 4.3.0 (2023-04-21)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Red Hat Enterprise Linux 8.6 (Ootpa)

**secrdesign** 2.9.1  
**secr** 4.6.7  

## Alternative capthist simulator

We use a custom function to generate an 'secr' capthist object within `run.scenarios`. We assume a single occasion. Arguments 'betaX', 'usermvn', 'makeuniform' and 'cov.structure' allow the function to be adapted for both the Moqanaki et al. and Dey et al. simulations.

```{r simMOQDEY code}
# function to return simulated capthist object
simMOQDEY.capthist <- function (traps, popn, detectfn, detectpar, noccasions = 1, 
    betaX = -0.5, phi = 1, usermvn = FALSE, makeuniform = FALSE, 
    cov.structure = c("exponential", "sq_exponential", "none"), ...)
{
    rmvn <- function(n, mu = 0, V = matrix(1), seed = NULL) {
        # based on Moqanaki 2021 code
        p <- length(mu)
        D <- V   # no Cholesky decomposition D <- chol(V)
        t(matrix(rnorm(n * p, mean = 0, sd = 1), ncol = p) %*% D + rep(mu, rep(n, p)))
    }
    if (!(detectfn == 0 || detectfn == "HN")) stop ("detectfn not implemented")
    cov.structure <- match.arg(cov.structure)
    K <- nrow(traps)
    N <- nrow(popn)
    trap.dists <- secr::edist(traps,traps)     # between traps
    
    if (cov.structure == "none") {
        p0 <- rep(detectpar$g0, K)
        X <- NA
    }
    else {
        if (cov.structure == "exponential")
            cov <- exp(-phi * trap.dists)     
        else if (cov.structure == "sq_exponential")
            cov <- exp(-phi^2 * trap.dists^2)   
        if (usermvn) 
            X <- rmvn(1, mu = rep(0, K), V = cov)   # as in Moqanaki et al.
        else 
            X <- mvtnorm::rmvnorm(1, mean = rep(0, K), sigma = cov) 
        X <- as.numeric(X)
        if (makeuniform) {
            # this code transforms the MVN values so they are uniformly 
            # distributed on [-1.96,1.96], as used by Moqanaki et al. 2021 
            # but not by Dey et al. 2023
            df <- data.frame(row = 1:K, orig.value = X)
            df <- df[order(df$orig.value),]
            df$value <- seq(-1.96, 1.96, length.out = K)
            df <- df[order(df$row), ]
            X <- df$value
        }
        
        # Moqanaki et al. (2021) Eq 8,9
        # Dey et al. (2023) implicitly set betaX = 1.0
        beta0 <- logit(detectpar$g0)            # intercept when no variation = logit(eta)
        p0 <- invlogit(beta0 + betaX * X)       # length K vector
    }
    # compute detection probability
    ac.dists   <- secr::edist(popn, traps)     # activity centres to traps
    p <- exp(-ac.dists^2/(2*detectpar$sigma^2))
    p <- sweep(p, 2, p0, "*")
    if (noccasions>1) {
        p <- aperm(apply(p,1:2,rep,noccasions), c(2,1,3))
    }
    # simulate detections
    if (detector(traps)[1] == 'proximity') {
        ch <- rbinom(N*K*noccasions, 1, p)
    }
    else if (detector(traps)[1] == 'count') {
        ch <- rpois(N*K*noccasions, -log(1-p))
    }
    else stop ("detector not proximity or count")
    ch <- array(ch, dim=c(N,noccasions,K))
    rownames(ch) <- 1:N
    ch <- ch[apply(ch, 1, function(x) sum(x) > 0),,, drop = FALSE]
    class(ch) <- 'capthist'
    traps(ch) <- traps
    attr(ch, 'X') <- X
    attr(ch, 'p0') <- p0
    ch
}
```

## Simulation code

A population of exactly 250 AC is distributed across 784 square units of habitat. In **secr** this translates to a density of about 3188.78 / hectare (each unit $1 \mbox m ^2$).

We use a squared exponential covariance structure as this most closely approximates the modified MVN used by Moqanaki et al. (see e.g. https://github.com/eMoqanaki/HeterogeneousDetectionSCR/issues/1).

```{r MOQ scenarios}
source('../setup.R')
grid400 <- make.grid(20, 20, spacex = 1, detector = 'proximity')
mask400 <- make.mask(grid400, buffer = 4.5)
poparg <- list(Ndist = 'fixed')
detarg <- expand.arg(phi           = c(0.001, 1, 1000), 
                     betaX         = seq(0, 2.5, 0.5), 
                     cov.structure = "sq_exponential", 
                     makeuniform   = TRUE)
fitarg <- list(details = list(distribution = 'binomial'))
scen <- make.scenarios(noccasions = 1, 
                       D          = 250/maskarea(mask400), 
                       g0         = 0.15, 
                       sigma      = 1.5, 
                       detectfn   = 'HN', 
                       detindex   = 1:length(detarg))
```

Simulate some data without fitting. Following Moqanaki et al. we use Moran's I to measure autocorrelation; the neighbour window includes adjacent detectors.
```{r MOQ summary, cache = TRUE, message = FALSE}
MOQtest <- run.scenarios(100, scen, grid400,CH.function = "simMOQDEY.capthist", 
    pop.args = poparg, det.args = detarg, fit = FALSE, extractfn = MoranX, varname = 'p0')

temp <- MoranXSummary(MOQtest, 'MoranI')
parm <- attr(detarg, 'comb')
cbind(parm, round(temp,3))

tempdnpa <- MoranXSummary(MOQtest, 'dnpa')
temprpsv <- MoranXSummary(MOQtest, 'rpsv')
```

```{r MOQ run, eval = FALSE}
MOQsims <- run.scenarios(
    nrepl       = 100, 
    scenarios   = scen, 
    trapset     = grid400, 
    maskset     = list(mask400), 
    CH.function = "simMOQDEY.capthist", 
    fit         = TRUE, 
    pop.args    = poparg, 
    det.args    = detarg, 
    fit.args    = fitarg)
saveRDS(MOQsims, file = 'MOQsims.RDS')
```

## Results

```{r, echo = FALSE}
MOQsims <- readRDS(file = 'MOQsims.RDS')
```

Runtime for `r MOQsims$nrepl` replicates using 24 cores was `r round(MOQsims$proctime/60)` minutes.

```{r MOQ results}
MOQsims <- readRDS(file = 'MOQsims.RDS')
parm
round(estimateSummary(MOQsims),4)
```

```{r MOQ figure, fig.width=10, fig.height=3.4}
plotone <- function (estD,estL,estS, phi) {
    plot(0,0, type = 'n', xlim=c(0,2.6), xlab = 'beta_X', ylab = 'RB', ylim=c(-0.4,0.6))
    abline(h=0, lty=2)
    rows <- parm$phi == phi
    addRB(parm$betaX[rows], estL[rows,], pch=21, bg='white', star = 0.6, xoffset=0.015)
    addRB(parm$betaX[rows], estS[rows,], pch=24, bg='white', star = 0.6, xoffset=0.03)
    addRB(parm$betaX[rows], estD[rows,], pch=16)
    mtext(side=3, paste0(' phi = ', phi), cex=0.8)
    legend(0, -0.2, legend=leg, pch=c(16,21,24))
}

MOQsims <- readRDS(file = 'MOQsims.RDS')
estD <- estimateSummary(MOQsims)
estL <- estimateSummary(MOQsims, 'g0')
estS <- estimateSummary(MOQsims, 'sigma')
leg <- c('D', 'g0','sigma')
par(mfrow=c(1,3), mar=c(4,4,1,1), mgp=c(2.4,0.7,0), bty = 'o')
x <- seq(0.5,2.5,0.5)
plotone(estD, estL, estS, 0.001)
plotone(estD, estL, estS, 1)
plotone(estD, estL, estS, 1000)
```

We expect $\nbox{RB}(\hat D)$ to approach zero for very small $\phi$ because then distances are 'shrunk' and detectors are nearly the same. The reverse appears to be the case in these simulations. That can be attributed to the transformation applied to the random field values: whatever the original range, the transformed value at any detector lies between -1.96 and +1.96. The range of values is then inflated by the $\beta_X$ parameter (e.g., $\beta_X = 2$ scales the variable component of $\mbox{logit}(p_0_j)$ to lie between -3.92 and +3.92)

# Dey et al. 2023

Dey et al. (2023) extended the simulations of Moqanaki et al. (2021) and implemented a random effects model. Their simulation conditions differed from those of Moqanaki et al. in minor ways; here we merely try to reproduce some results with the SECR null model.

## Settings

Square grid of 1024 binary proximity detectors at unit spacing $c$.  

The same conditions used for simulation and fitting.

| Parameter | Value(s) |
|:-----|:-----------------------|
| detectfn | 'HN' |
| D | $0.40155 \sigma^{-2}$ |
| N | fixed |
| k | 0.634 |
| base g0  | 0.1, 0.3, 0.6 |
| sigma    | $1.5c$ |
| noccasions | 1 |
| buffer   | $3\sigma$ |
| nx       | 64 |

## Package version, date and platform

**secrdesign** 2.9.1  
**secr** 4.6.7  

2024-03-29

R version 4.3.0 (2023-04-21)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Red Hat Enterprise Linux 8.6 (Ootpa)

## Simulation code

```{r DEY scenarios}
source('../setup.R')
grid1024 <- make.grid(32, 32, spacex = 1, detector = 'proximity')
mask1024 <- make.mask(grid1024, buffer = 5)
poparg <- list(Ndist = 'fixed')
detarg <- expand.arg(phi = c(1,0.05), betaX = 1, cov.structure = "exponential")
fitarg <- list(details = list(distribution = 'binomial'))
scen <- make.scenarios(noccasions = 1, 
                       D          = 300/maskarea(mask1024), 
                       g0         = c(0.1,0.3,0.6), 
                       sigma      = 1.5, 
                       detectfn   = 'HN', 
                       detindex   = 1:length(detarg))
scen <- scen[order(scen$g0, scen$detindex),]
scen$scenario <- 1:6
```

Simulate some data without fitting to check Moran's I.

```{r DEY summary, message = FALSE, cache = TRUE}
DEYtest <- run.scenarios(
    nrepl       = 100, 
    scenarios   = scen, 
    trapset     = grid1024, 
    maskset     = mask1024, 
    CH.function = "simMOQDEY.capthist", 
    fit         = FALSE, 
    pop.args    = poparg, 
    det.args    = detarg, 
    extractfn   = MoranX)
```
```{r DEY summary1}
tempMoranI <- MoranXSummary(DEYtest, 'MoranI')
cbind(scen[,c('g0', 'detindex')], round(tempMoranI,3))
tempdnpa <- MoranXSummary(DEYtest, 'dnpa')
temprpsv <- MoranXSummary(DEYtest, 'rpsv')
```

```{r DEY parm}
parm <- attr(detarg, 'comb')[,1,drop=F]
```

```{r DEY run, eval = FALSE}
DEYsims <- run.scenarios(
    nrepl       = 100, 
    scenarios   = scen, 
    trapset     = grid1024, 
    maskset     = list(mask1024), 
    CH.function = "simMOQDEY.capthist", 
    fit         = TRUE, 
    pop.args    = poparg, 
    det.args    = detarg, 
    fit.args    = fitarg)
saveRDS(DEYsims, file = 'DEYsims.RDS')
```

```{r DEY results}
DEYsims <- readRDS(file = 'DEYsims.RDS')
cbind(g0 = scen$g0, phi = c(1,0.05)[scen$detindex], round(estimateSummary(DEYsims),4))
```

Broadly match Dey et al. [Table S1], but some signs of systematic difference in simulations.

[Table S1]: https://ars.els-cdn.com/content/image/1-s2.0-S0304380023000522-mmc1.zip

## Additional DEY simulations: varying $\phi$

```{r DEY scenarios 2}
source('../setup.R')
grid1024 <- make.grid(32, 32, spacex = 1, detector = 'proximity')
mask1024 <- make.mask(grid1024, buffer = 5)
poparg <- list(Ndist = 'fixed')
detarg <- expand.arg(phi = 10^seq(-3,1,0.5), betaX = 1, cov.structure = "exponential")
fitarg <- list(details = list(distribution = 'binomial'))
scen <- make.scenarios(noccasions = 1, 
                       D          = 300/maskarea(mask1024), 
                       g0         = 0.1, 
                       sigma      = 1.5, 
                       detectfn   = 'HN', 
                       detindex   = 1:length(detarg))
```

Simulate some data without fitting 
```{r DEY summary 2, cache = TRUE}
DEYtest2 <- run.scenarios(
    nrepl       = 100, 
    scenarios   = scen, 
    trapset     = grid1024, 
    maskset     = mask1024, 
    CH.function = "simMOQDEY.capthist", 
    fit         = FALSE, 
    pop.args    = poparg, 
    det.args    = detarg, 
    extractfn   = extrfn)
```
```{r DEY summary 2a}
temp <- t(sapply(summary(DEYtest2)$OUTPUT, '[', , 'mean'))
dimnames(temp) <- list(NULL,  c('n', 'n+r', 'mean.p0', 'sd.p0', 'MoranI'))
cbind(scen[,c('g0', 'detindex')], round(temp,3))
```

```{r DEY run 2, eval = FALSE}
DEYsims2 <- run.scenarios(
    nrepl       = 100, 
    scenarios   = scen, 
    trapset     = grid1024, 
    maskset     = list(mask1024), 
    CH.function = "simMOQDEY.capthist", 
    fit         = TRUE, 
    pop.args    = poparg, 
    det.args    = detarg, 
    fit.args    = fitarg)
saveRDS(DEYsims2, file = 'DEYsims2.RDS')
```

```{r DEY 2 results, eval = TRUE}
DEYsims2 <- readRDS(file = 'DEYsims2.RDS')
estD <- estimateSummary(DEYsims2, 'D')
estL <- estimateSummary(DEYsims2, 'g0')
estS <- estimateSummary(DEYsims2, 'sigma')
cbind(g0 = scen$g0, phi = 10^seq(-3,1,0.5), round(estD,4))
getcounts(DEYsims2)

leg <- c('D', 'g0','sigma')
phi <- 10^seq(-3,1,0.5)
par(mfrow=c(1,1), mar=c(5,4,2,2), mgp=c(2.4,0.7,0), pty='s', bty = 'o')
plot(1,1, type = 'n', xlim=c(0.001,10), xlab = 'phi', ylab = 'RB', log = 'x', ylim=c(-0.5,0.8))
abline(h=0, lty=2)
addRB(phi, estL, pch=21, bg='white', star = 0.8)
addRB(phi, estS, pch=24, bg='white', star = 0.8)
addRB(phi, estD, pch=16)
legend(0, -0.2, legend=leg, pch=c(16,21,24))
abline (v=0.05, col='grey')
lines(phi, temp[,'MoranI']*0.3 - 0.5)
axis(4, at = seq(-0.5,-0.2, 0.15), c(0,0.5,1))
mtext(side=4, line=2, at = -0.35, "Moran's I")
```

```{r DEY 2 check, eval = TRUE, cache = TRUE}
pop <- sim.popn(D = 300/maskarea(mask1024), core = grid1024, buffer = 5, Ndist = 'fixed')
par(mfrow=c(3,3), mar=c(1,1,2,1))
for (phi in 10^seq(-3,1,0.5)) {
    ch <- simMOQDEY.capthist(grid1024, popn = pop, detectfn = 'HN', 
                           detectpar=list(g0=0.1, sigma = 1.5), 
                           phi = phi, betaX = 1, cov.structure = "exponential")
    covariates(grid1024)$p0 <- attr(ch, 'p0')
    plot(as.mask(grid1024), cov = 'p0', dots = FALSE, legend = FALSE, border=1,
         breaks = c(seq(0,0.6,0.02),1))
    mtext(side = 3, paste0('phi = ', round(phi,5), ' p0 = ', round(mean(attr(ch, 'p0')),4)))
}
```

# Relationship between SARE and individual heterogeneity

It has long been recognised that variation among detectors (SARE) causes heterogeneity of detection among individuals that leads to bias in $\hat D$ (Royle et al. (2013), Efford (2014)). Whether induced individual heterogeneity is a sufficient explanation for the observed $\mbox{RB}(\hat D)$ is an open question. The hypothesis implies that $\mbox{RB}(\hat D)$ is tightly correlated with a measure of heterogeneity over a variety of SARE scenarios that yield similar precision.

Heterogeneity in non-spatial capture-recapture is measured by the coefficient of variation of detection probability $\mbox{CV}(p_i)$ (Carothers 1979, Seber 1982:, Pledger and Efford 1998). The issue is more subtle in SECR because of the interaction between detection parameters (e.g., $\lambda_0, \sigma$). Efford and Mowat (2014) proposed $\mbox{CV}(a_i)$ as a suitable measure, where $a_i = \int p_\cdot(\vec x) \, d\vec x$ and $p_\cdot(\vec x) = 1 - \exp(-\sum_s\sum_k h_{sk}(\vec x))$ where $h_{sk}(\vec x)$ is the hazard of detection at detector $k$ on occasion $s$ for an animal at $\vec x$. Under the hazard halfnormal detection model $h_{sk}(\vec x) = \lambda_0 \exp\left(\frac{-|\vec x - \vec x_k|^2}{2\sigma^2}\right)$

SARE scenarios have been limited to variation in $\lambda_0$, with $\sigma$ constant, and for these it is sufficient to consider $\mbox{CV}(\lambda_0)$.  

```{r check, echo = FALSE, eval = FALSE}
simRSFCV <- function (nrepl = 100, traps, mask, sigma = 2, noccasions = 10, 
                      alpha0 = -2, alpha2 = 1, scale = 5, plt = 'CV')
{
    N <- nrow(mask)
    K <- nrow(traps)
    cov <- exp(-edist(traps,traps)/scale)  
    base.er <- exp(-edist(mask, traps)^2/2/sigma^2)
    one <- function (r) {
        X <- mvtnorm::rmvnorm(1, mean = rep(0, K), sigma = cov) 
        lambda0 <- exp(alpha0 + alpha2 * X)       # length K vector
        h.mat <- sweep(base.er, MARGIN = 2, STATS = lambda0, FUN = '*') * noccasions
        1 - exp(-apply(h.mat,1,sum))  # prob detected at least once
    }
    reps <- sapply(1:nrepl, one)
    covariates(mask)$mean <- apply(reps,1,mean)
    covariates(mask)$sd <- apply(reps,1,sd)
    covariates(mask)$CV <- apply(reps,1,CV)
    covariates(mask)$weighted <- covariates(mask)$sd / sum(covariates(mask)$mean)  * nrow(mask)
    if (plt != '') {
        plot(mask, cov=plt, dots=F, border = 10)
        plot(traps, add=TRUE)
    }
    list (weighted = sum(covariates(mask)$sd) / sum(covariates(mask)$mean),
          mask = mask)
    # maskzone <- covariates(mask)$maskzone
    # data.frame(CVa = CV(apply(reps,2,sum)),
    #            zone = levels(maskzone),
    #            mean = tapply(covariates(mask)$mean, maskzone, mean),
    #            CV = tapply(covariates(mask)$CV, maskzone, mean))
}

msk <- make.mask(grid49, buffer = 12)
dtt <- distancetotrap(msk, grid49)
covariates(msk)$maskzone <- cut(dtt, c(0,4,6,8,10,20))
plot(msk, cov='maskzone', dots=F)
plot(grid49, add=T)

alpha2val <- seq(0,1.4,0.2)
mncv <- lapply(alpha2val, simRSFCV, nrepl = 1000, traps = grid49, mask = msk,
               sigma = 2, noccasions = 10, alpha0 = -2, scale = 5)

par(mfrow=c(1,1), mar=c(4,4,2,2))
plot(0,0,xlim=c(0,12),ylim=c(0,2.2), type='n',xlab='Zone', ylab='CV(pdot)')
lapply(mncv, function(x) points(c(2,5,7,9,11), x[,'CV'], type='o', pch=16))
points(c(2,5,7,9,11), mncv[[1]][,'mean'], type='o', pch=1)
points(c(2,5,7,9,11), mncv[[6]][,'mean'], type='o', pch=1)

# Global CV over all x
RSFsims2 <- readRDS(file = 'RSFsims2.RDS')
estD <- estimateSummary(RSFsims2, 'D')

plot(sapply(mncv, '[[', 'weighted'), estD$RB)

plot(mncv[[8]]$mask, cov='weighted', dots=F)
     
     lnorm <- function (meanlog, sdlog) {
    mean <- exp(meanlog + sdlog^2/2)
    sd <- sqrt((exp(sdlog^2) - 1) * exp(2 * meanlog + sdlog^2))
    c(mean = mean, sd = sd, cv = sd/mean)
}
sapply(seq(0,1.4,0.2), lnorm, meanlog = -2)   # checked
```
